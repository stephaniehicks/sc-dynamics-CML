---
title: Analysis of scRNA-seq data from CML patient 0114 (Jan 14, 2019)
author: Stephanie Hicks
output: 
    html_document:
        theme: cosmo 
        toc: true
        toc_float: true
        highlight: tango
        number_sections: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, 
                      message = FALSE)
# workingPath <- "/users/shicks1/projects/sc-dynamics-CML"
here::here()
```

# Summary of patient data

This is scRNA-seq (10X Genomics platform) data from a MPN patient 
(denoted `0114` patient) from Jan 14, 2019. The data is available 
on the JHPCE cluster and the following files are in the folder: 

- `barcodes_2.tsv`: barcode sequences of the detected cells.
- `features.tsv`: names of the genes (columns of the count matrix)
- `mycounts_2.csv`: count matrix (445.8 MB in size). The rows are the cells and the columns are the genes (6598 cells, 33694 genes). Each entry is the number of detected transcripts of a given gene in a given cell.
- `mygroupings_threshold_NS_100_Rev2.csv`: contains the number of wild-type or cancer transcripts detected in each cell. The columns are the cells (same number as the rows of the count matrix). There are two rows. Row 1 is the number of WT Jak2 transcripts. Row 2 is the number of cancer Jak2 transcripts.

The count matrix above is from our first sequencing run on this patient library. However, it has since been resequenced to increase depth by a factor of 3. This higher-depth data should be available by our meeting in Boston on March 8, 2019. 

## Previous analyses reported by Sahand

"We use SPRING, a dimensionality reduction 
tool that uses force-directed graph to plot the
differentiation trajectories. SPRING has some
criteria for selecting a subset of genes that are 
informative (for example fano factor and mean expression 
thresholds)."

# Biological question of interest

* Interested in identifying genes that are over-expressed or under-expressed in the cancer cells.
* Are there differences between cancer and normal cells in genes that regulate cell cycle?
* Hypothesis: Previous analyses suggested the gene E2F4 is over expressed in the cancer cells.

# Data Analysis

## Load data
Read in data 
```{r load-data, message=FALSE, cache=TRUE, eval=FALSE}
dat_counts <- readr::read_csv(file.path(workingPath, "data/0114P_RNAseq/BM_CD34/mycounts_2.csv"),
                              col_names = FALSE) # dat is 445.8 MB in size
dat_counts <- t(dat_counts) # flip to make cells along columns

dat_muts <- readr::read_csv(file.path(workingPath, 
  "data/0114P_RNAseq/BM_CD34/mygroupings_threshold_NS_100_Rev2.csv"), 
  col_names = FALSE)
dat_features <- readr::read_tsv(file.path(workingPath, 
  "data/0114P_RNAseq/BM_CD34/features.tsv"), 
  col_names = FALSE)
dat_barcodes <- readr::read_tsv(file.path(workingPath, 
  "data/0114P_RNAseq/BM_CD34/barcodes_2.tsv"), 
  col_names = FALSE)
```

Create a `SingleCellExperiment` object
```{r create-sce-object, message=FALSE, cache=TRUE, eval=FALSE}
library(SingleCellExperiment)

# row meta data 
sce_rowData <- as.data.frame(dat_features[,1:2])
colnames(sce_rowData) <- c("gene_name_ensembl", 
                           "gene_name_symbol")
rownames(sce_rowData) <- sce_rowData$gene_name_ensembl

# column meta data 
sce_colData <- data.frame("jak2_reads_wt" = as.numeric(dat_muts[1, -1]), 
                          "jak2_reads_cancer" = as.numeric(dat_muts[2, -1]))
rownames(sce_colData) <- dat_barcodes$X1

# counts matrix 
rownames(dat_counts) <- sce_rowData$gene_name_ensembl
colnames(dat_counts) <- dat_barcodes$X1

sce <- SingleCellExperiment(assays = list(counts = dat_counts), 
          rowData = sce_rowData, colData = sce_colData)
```

## Quality control 

```{r scater-qc-basic, message=FALSE, cache=TRUE, eval=FALSE}
library(scater)

sce <- getBMFeatureAnnos(sce, 
            ids = rownames(sce),
            filters = "ensembl_gene_id", 
            attributes = c("ensembl_gene_id", "hgnc_symbol",
                           "chromosome_name", "gene_biotype",
                           "start_position", "end_position"),
            biomart = "ENSEMBL_MART_ENSEMBL", 
            dataset = "hsapiens_gene_ensembl",
            host = "www.ensembl.org")

# separate information about mitochondrial genes
rowData(sce)[grep("^MT-", rowData(sce)$gene_name_symbol),]
isSpike(sce, "MT") <- grepl("^MT-", rowData(sce)$gene_name_symbol)

# calculate QC metrics
sce <- calculateQCMetrics(sce)

# save SCE object
saveRDS(sce, file = file.path(workingPath, 
                      "data/0114P_RNAseq/BM_CD34/sce_0114.rds"))
```


### Exploratory data analysis on cells 

```{r}
library(SingleCellExperiment)
library(scater)
sce <- readRDS(file.path(workingPath, "data/0114P_RNAseq/BM_CD34/sce_0114.rds"))
```


Histogram of library sizes and number 
of expressed genes.
```{r}
par(mfrow=c(1,2))
hist(sce$total_counts/1e4, xlab="Library sizes (thousands)", main="",
     breaks=20, col="grey80", ylab="Number of cells")
hist(sce$total_features_by_counts, xlab="Number of expressed genes", main="",
     breaks=20, col="grey80", ylab="Number of cells")
```

Here is a table of the number of wild-type or cancer transcripts
detected in each cell covering Jak2. There are e.g. 11 cells that 
both have 1 read from the wildtype and cancer transcripts. 

```{r}
table(sce$jak2_reads_cancer, sce$jak2_reads_wt)
```

Following up with Sahand from our March 8 jam session in Boston, 
we assume that if we see at least one mutant/cancer read covering 
Jak2, then we call it a cancer cell.  

```{r}
sce$cancer_status <- ifelse(sce$jak2_reads_cancer > 0, "mut", 
  ifelse((sce$jak2_reads_cancer < 1 & sce$jak2_reads_wt > 0), "wt", "unknown" ))
sce$cancer_status <- factor(sce$cancer_status, levels=c("wt", "mut", "unknown"))
table(sce$cancer_status)
```

Let's look at the distribution of total counts and number 
of expressed genes when we stratify by the number of cancer 
reads or wild type reads. Also what happens when you stratify 
by cancer status

```{r, fig.height=8, fig.width=12}
par(mfrow=c(2,3))
boxplot(sce$total_counts ~ sce$jak2_reads_cancer, log="y", 
        main = "jak2_reads_cancer", ylab = "total_counts" )
boxplot(sce$total_counts ~ sce$jak2_reads_wt, log="y", 
        main = "jak2_read_wt", ylab = "total_counts")
boxplot(sce$total_counts ~ sce$cancer_status, log="y", 
        main = "cancer_status", ylab = "total_counts")

boxplot(sce$total_features_by_counts ~ sce$jak2_reads_cancer, log="y", 
        main = "jak2_reads_cancer", ylab = "total_features_by_counts" )
boxplot(sce$total_features_by_counts ~ sce$jak2_reads_wt, log="y", 
        main = "jak2_read_wt", ylab = "total_features_by_counts")
boxplot(sce$total_features_by_counts ~ sce$cancer_status, log="y", 
        main = "cancer_status", ylab = "total_features_by_counts")
```

We should also look at the percent of reads mapping to MT genes, 
which could be evidence that we should exclude these cells

```{r, fig.width=8}
par(mfrow=c(1,2))
boxplot(sce$pct_counts_MT ~ sce$cancer_status, ylim = c(0, 50), 
        ylab = "pct_counts_MT", main = "cancer_status")
plot(sce$total_features_by_counts, sce$pct_counts_MT)
```

There are definitely cells that have much higher pct MT
in the `unknown` cancer status group. 


### Remove low-quality cells 

We remove cells with log-library sizes that are more than 
3 median absolute deviations (MADs) below the median 
log-library size. (A log-transformation improves resolution 
at small values, especially when the MAD of the raw values 
is comparable to or greater than the median). Next, we 
remove cells where the log-transformed number of expressed 
genes is 3 MADs below the median. Then, we remove cells 
with percent MT 3 MADs above the median. 

```{r}
libsize.drop <- isOutlier(sce$total_counts, nmads=3, type="lower", log=TRUE)
feature.drop <- isOutlier(sce$total_features_by_counts, nmads=3, type="lower", log=TRUE)
MT.drop <- isOutlier(sce$pct_counts_MT, nmads=3, type="higher", log=TRUE)

data.frame(ByLibSize=sum(libsize.drop), ByFeature=sum(feature.drop), 
    BySpike=sum(MT.drop), Remaining=ncol(sce))

sce <- sce[,!(libsize.drop | feature.drop | MT.drop)]

# sanity check
par(mfrow=c(1,1))
plot(sce$total_features_by_counts, sce$pct_counts_MT)
```

### Classification of cell cycle phase

We use the prediction method described by Scialdone 
et al. (2015) to classify cells into cell cycle phases 
based on the gene expression data. Using a training dataset, 
the sign of the difference in expression between two genes 
was computed for each pair of genes. Pairs with changes in the 
sign across cell cycle phases were chosen as markers. Cells in 
a test dataset can then be classified into the appropriate 
phase, based on whether the observed sign for each marker pair 
is consistent with one phase or another.

This approach is implemented in the cyclone function from the 
scran package. The package contains a pre-trained set of marker 
pairs for mouse and human data, which we can load in the the 
`readRDS()` function. We use the Ensembl identifiers for each 
gene in our dataset to match up with the names in the pre-trained 
set of gene pairs.

Then, this can take a while to run. 
```{r, eval=FALSE}
library(scran)
human.pairs <- readRDS(system.file("exdata", "human_cycle_markers.rds", package="scran"))
assigned <- cyclone(sce, pairs=human.pairs, gene.names=rowData(sce)$ensembl_gene_id)
```

The cyclone result for each cell in the dataset is shown above. 
Each cell is assigned a score for each phase, with a higher score 
corresponding to a higher probability that the cell is in that 
phase. We focus on the G1 and G2/M scores as these are the 
most informative for classification.

Cells are classified as being in G1 phase if the G1 score 
is above 0.5 and greater than the G2/M score; in G2/M phase 
if the G2/M score is above 0.5 and greater than the G1 score; 
and in S phase if neither score is above 0.5. We save these 
assignments into the `SingleCellExperiment` object for later use.

```{r, eval=FALSE}
sce$phases <- assigned$phases
sce$cellcycle_score_G1 <- assigned$score$G1
sce$cellcycle_score_G2M <- assigned$score$G2M
sce$cellcycle_score_S <- assigned$score$S
sce$cellcycle_score_normalized_G1 <- assigned$normalized.scores$G1
sce$cellcycle_score_normalized_G2M <- assigned$normalized.scores$G2M
sce$cellcycle_score_normalized_S <- assigned$normalized.scores$S

saveRDS(sce, file = file.path(workingPath, "data/0114P_RNAseq/BM_CD34/sce_qc_0114.rds"))
```

We can plot the cell cycle scores for 
G1 and G2M phases. 

```{r, fig.width=8}
library(SingleCellExperiment)
library(scater)

sce <- readRDS(file.path(workingPath, "data/0114P_RNAseq/BM_CD34/sce_qc_0114.rds"))
```

```{r}
library(tidyverse)
library(cowplot)

p1 <- as.data.frame(colData(sce)) %>% 
  ggplot(aes(x=cellcycle_score_G1, y=cellcycle_score_G2M, 
             color = cancer_status)) +
  geom_point()

p2 <- as.data.frame(colData(sce)) %>% 
  ggplot(aes(x=cellcycle_score_G1, y=cellcycle_score_G2M, 
             color = phases)) + 
  geom_point()

plot_grid(p1, p2, ncol=2, labels = LETTERS[1:2])
```

Let's save this figure.
```{r, eval=FALSE}
pdf(file.path(workingPath, "figures/2019-03-07-cell-cycle.pdf"), width=12,height=4)
plot_grid(p1, p2, ncol=2, labels = LETTERS[1:2])
dev.off()
```

We can calculate the absolute numbers and the 
proportion of cells in each cell cycle phase 
```{r}
table(sce$phases)

x <- table(factor(sce$cancer_status[sce$cancer_status != "unknown"]), 
      sce$phases[sce$cancer_status != "unknown"]) 
x

round(x / rowSums(x), 3)
chisq.test(x) 
```

We see the p-value is `r round(chisq.test(x)$p.value, 5)`, which is statistically
signicant at the $\alpha$=0.05 level. 

**Note**: We do not filter out low-abundance genes before 
applying cyclone. Even if a gene is not expressed in any cell, 
it may still be useful for classification if it is phase-specific. 
Its lack of expression relative to other genes will still yield 
informatived pairs, and filtering them out would reduce power.


## EDA and QC on the genes

Next we want to filter out low abundance 
genes. First let's look at which genes are the
most highly expressed

```{r}
fontsize <- theme(axis.text=element_text(size=12), 
                  axis.title=element_text(size=16))

plotHighestExprs(sce, n=25, 
                 feature_names_to_plot = "gene_name_symbol") + 
  fontsize
```

We will consider the average count for each gene, 
computed across all cells in the dataset. We calculate
this using the `calcAverage()` function, which also 
performs some adjustment for library size differences 
between cells. 

```{r}
# Remove genes not greater than a certain threshold in avg expression
par(mfrow=c(1,1))
ave.counts <- calcAverage(sce, use_size_factors=FALSE)
hist(log10(ave.counts), breaks=100, main="", col="grey80", 
    xlab=expression(Log[10]~"average count"))
```

We see a lot of genes are really lowly expressed! 

We can also look at genes expressed in at least $N$ cells. 
This is closely related to the average count for most genes, 
as expression in many cells will result in a higher average. 
Genes expressed in very few cells are often uninteresting as 
they are driven by amplification artifacts (though they may 
also also arise from rare populations). We could then remove 
genes that are expressed in fewer than $N$ cells.

```{r}
num.cells <- nexprs(sce, byrow=TRUE)
smoothScatter(log10(ave.counts), num.cells, ylab="Number of cells", 
    xlab=expression(Log[10]~"average count"))
```

This plot suggestions we should consider removing genes 
with a min average gene expression of 0.01 
(or -3 or -2 on `log10` scale). We also remove genes without 
expression in at least 1 cell. Finally, I needed to 
remove a cell that had zero reads in the MT genes
which will cause trouble for normalization if not
addressed here. 
```{r}
keep_feature <- (num.cells > 1) & (log10(ave.counts) > -3)
keep_cell_MT <- !(colSums(counts(sce[isSpike(sce), ])) == 0)
table(keep_feature)
table(keep_cell_MT)

sce_norm <- sce[keep_feature, keep_cell_MT]
sce_norm
```


## Normalization

We compute size factors for the endogenous genes 
using the deconvolution method (Lun, Bach, and Marioni 2016).
This is done with pre-clustering through `quickCluster()`
to avoid pooling together very different cells.

```{r, eval=FALSE}
library(scran)
set.seed(1000)

clusters <- quickCluster(sce_norm, method="igraph", min.mean=0.01)
table(clusters)

sce_norm <- computeSumFactors(sce_norm, min.mean=0.01, clusters=clusters)
summary(sizeFactors(sce_norm))
```

```{r, eval=FALSE}
sce_norm <- computeSpikeFactors(sce_norm, type="MT", general.use=FALSE)
```

Finally, normalized log-expression values are computed for
each endogenous gene or spike-in transcript using the
appropriate size factors.

```{r, eval=FALSE}
sce_norm <- normalize(sce_norm)
saveRDS(sce_norm, file = file.path(workingPath, 
                      "data/0114P_RNAseq/BM_CD34/sce_norm_0114.rds"))
```


## Filter for highly variable genes

```{r}
sce_norm <- readRDS(file.path(workingPath, 
                    "data/0114P_RNAseq/BM_CD34/sce_norm_0114.rds"))

library(scran)
keep_cell_MT <- (colSums(counts(sce_norm[isSpike(sce_norm), ])) >1)
sce_norm <- sce_norm[, keep_cell_MT]
sce_norm
```

```{r}
var.fit <- trendVar(sce_norm, parametric=FALSE)
var.out <- decomposeVar(sce_norm, var.fit)
var.out$gene_name_symbol <- rowData(sce_norm)$gene_name_symbol
plot(var.out$mean, var.out$total, pch=16, cex=0.6, xlab="Mean log-expression", 
    ylab="Variance of log-expression")
curve(var.fit$trend(x), col="dodgerblue", lwd=2, add=TRUE)
cur.spike <- isSpike(sce_norm)
points(var.out$mean[cur.spike], var.out$total[cur.spike], col="red", pch=16)
```

We define HVGs as those genes that have a biological component 
that is significantly greater than zero. We use a false discovery 
rate (FDR) of 5% after correcting for multiple testing with 
the Benjamini-Hochberg method.

```{r}
hvg.out <- var.out[which(var.out$FDR <= 0.05),]
nrow(hvg.out)
```

We rank the results to focus on genes with larger biological 
components. This highlights an interesting aspect of the underlying 
hypothesis test, which is based on the ratio of the total variance 
to the expected technical variance. Ranking based on p-value tends 
to prioritize HVGs that are more likely to be true positives but, 
at the same time, less likely to be interesting. This is because 
the ratio can be very large for HVGs that have very low total 
variance and do not contribute much to the cell-cell heterogeneity.
```{r}
hvg.out <- hvg.out[order(hvg.out$bio, decreasing=TRUE),] 
head(hvg.out)
```

```{r}
# remove MT genes for downstream analyses
sce_sub <- sce_norm[!rowData(sce_norm)$is_feature_control, ] 
sce_sub <- sce_sub[rownames(hvg.out), ]
```


## Dimensionality reduction 

```{r}
rownames(sce_sub) <- rowData(sce_sub)$gene_name_symbol

library(scater)
# Using irlba to set up the umap for speed.
sce_sub <- runPCA(sce_sub, ntop=Inf, method="irlba", ncomponents=20)
```

```{r umap-1}
set.seed(1234)
sce_sub <- runUMAP(sce_sub, ncomponents = 2, ntop=500)
plotUMAP(sce_sub, colour_by="cancer_status") + ggtitle("umap")
plotUMAP(sce_sub, colour_by="CD34") + ggtitle("umap")
```

```{r umap-E}
plotUMAP(sce_sub, colour_by="HBB") + ggtitle("umap (E -- HBB)") # E
```

```{r umap-Ba}
plotUMAP(sce_sub, colour_by="LMO4") + ggtitle("umap (Ba -- Lmo4)") # Ba
```

```{r umap-MEG}
plotUMAP(sce_sub, colour_by="ITGA2B") + ggtitle("umap (MEG -- ITGA2B)") # MEG
```

```{r umap-MPP}
plotUMAP(sce_sub, colour_by="HLF") + ggtitle("umap (MPP -- HLF)") # MPP
```

```{r umap-Ly}
plotUMAP(sce_sub, colour_by="CD79A") + ggtitle("umap (Ly -- CD79A)") # Ly
```

```{r umap-M}
plotUMAP(sce_sub, colour_by="CSF1R") + ggtitle("umap (M -- CCR2)") # M
```

```{r umap-G}
plotUMAP(sce_sub, colour_by="MPO") + ggtitle("umap (MPO)") # G
```

# slingshot 

The minimal input to `slingshot` is a matrix representing the 
cells in a reduced-dimensional space and a vector of cluster labels.

With these two inputs, we then:

1. Identify the global lineage structure by constructing an minimum spanning tree (MST) on the clusters, with the `getLineages()` function.
2. Construct smooth lineages and infer pseudotime variables by fitting simultaneous principal curves with the `getCurves()` function.
3. Assess the output of each step with built-in visualization tools.

Firs, we use the reduced dims from `umap`. 
```{r}
rd <- reducedDim(sce_sub, "UMAP")
```

For cluster labels, 
```{r}
k.max <- 15
data <- rd
wss <- sapply(1:k.max, 
              function(k){kmeans(data, k, nstart=50,iter.max = 15 )$tot.withinss})
wss

plot(1:k.max, wss,
     type="b", pch = 19, frame = FALSE, 
     xlab="Number of clusters K", main = "Elbow plot",
     ylab="Total within-clusters sum of squares")
```

So let's go with 8? 
```{r}
set.seed(123)
k_out <- kmeans(rd, centers = 9)
plot(rd, col = k_out$cluster)

sce_sub$cluster_labels <- k_out$cluster
```

To run slingshot with the dimensionality reduction produced by PCA and cluster labels identified by Gaussian mixutre modeling, we would do the following:

```{r}
lin1 <- getLineages(rd, sce_sub$cluster_labels, start.clus = '6')
plot(rd, col = brewer.pal(9,"Set1")[sce_sub$cluster_labels], asp = 1, pch = 16)
lines(lin1, lwd = 3, show.constraints = TRUE)

crv1 <- getCurves(lin1)
plot(rd, col = brewer.pal(9,"Set1")[sce_sub$cluster_labels], asp = 1, pch = 16)
lines(crv1, lwd = 3)

plot(rd, col = colors[cut(sce_sub$slingPseudotime_1,breaks=100)], 
     pch=16, asp = 1)
lines(SlingshotDataSet(sce_sub), lwd=2)

```


```{r}
library(slingshot)
library(RColorBrewer)
sce_sub <- slingshot(sce_sub, clusterLabels = 'cluster_labels', reducedDim = 'UMAP')
```

```{r}
summary(sce_sub$slingPseudotime_1)
colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100)
plot(reducedDims(sce_sub)$UMAP, 
     col = colors[cut(sce_sub$slingPseudotime_1,breaks=100)], 
     pch=16, asp = 1)
lines(SlingshotDataSet(sce_sub), lwd=2)
```

We can also see how the lineage structure was intially estimated by the cluster-based minimum spanning tree by using the type argument.

```{r}
plot(reducedDims(sce_sub)$UMAP, 
     col = brewer.pal(8,'Set1')[sce_sub$cluster_labels],
     pch=16, asp = 1)
lines(SlingshotDataSet(sce_sub), lwd=2, type = 'lineages')
```

## Identifying temporally expressed genes using `slingshot`

After running `slingshot`, here, we find genes that change 
their expression over the course of development. We use the 
1000 most variable genes.

We will regress each gene on the pseudotime variable we
have generated, using a general additive model (GAM). This
allows us to detect non-linear patterns in gene expression.

```{r}
require(gam)
t <- sce_sub$slingPseudotime_1

# for time, only look at the 1,000 most variable genes
Y <- assays(sce_sub[1:100,])$logcounts

# fit a GAM with a loess term for pseudotime
gam.pval <- apply(Y,1,function(z){
  d <- data.frame(z=z, t=t)
  tmp <- gam(z ~ lo(t), data=d)
  p <- summary(tmp)[4][[1]][1,5]
  p
})
```

We can then pick out the top genes based on p-value and visualize their expression over developmental time with a heatmap.

```{r}
require(clusterExperiment)

topgenes <- names(sort(gam.pval, decreasing = FALSE))[1:50]
heatdata <- logcounts(sce_sub)[rownames(logcounts(sce_sub)) %in% topgenes, 
                        order(t, na.last = NA)]
heatclus <- sce_sub$cluster_labels[order(t, na.last = NA)]
ce <- ClusterExperiment(heatdata, heatclus, transformation = log1p)
```

```{r, eval=FALSE}
pdf(file.path(workingPath, "figures/2019-04-02-slingshot-heatmap.pdf"), width=12,height=4)
  plotHeatmap(ce, clusterSamplesData = "orderSamplesValue", visualizeData = 'transformed')
dev.off()
```

```{r, eval=FALSE}
p1 <- plotUMAP(sce_sub, colour_by=topgenes[1]) + ggtitle("umap")
p2 <- plotUMAP(sce_sub, colour_by=topgenes[2]) + ggtitle("umap")
p3 <- plotUMAP(sce_sub, colour_by=topgenes[3]) + ggtitle("umap")
p4 <- plotUMAP(sce_sub, colour_by=topgenes[4]) + ggtitle("umap")
p5 <- plotUMAP(sce_sub, colour_by=topgenes[5]) + ggtitle("umap")
p6 <- plotUMAP(sce_sub, colour_by=topgenes[6]) + ggtitle("umap")
p7 <- plotUMAP(sce_sub, colour_by=topgenes[7]) + ggtitle("umap")
p8 <- plotUMAP(sce_sub, colour_by=topgenes[8]) + ggtitle("umap")
p9 <- plotUMAP(sce_sub, colour_by=topgenes[9]) + ggtitle("umap")
p10 <- plotUMAP(sce_sub, colour_by=topgenes[10]) + ggtitle("umap")
p11 <- plotUMAP(sce_sub, colour_by=topgenes[11]) + ggtitle("umap")
p12 <- plotUMAP(sce_sub, colour_by=topgenes[12]) + ggtitle("umap")
p13 <- plotUMAP(sce_sub, colour_by=topgenes[13]) + ggtitle("umap")
p14 <- plotUMAP(sce_sub, colour_by=topgenes[14]) + ggtitle("umap")
p15 <- plotUMAP(sce_sub, colour_by=topgenes[15]) + ggtitle("umap")
p16 <- plotUMAP(sce_sub, colour_by=topgenes[16]) + ggtitle("umap")
p17 <- plotUMAP(sce_sub, colour_by=topgenes[17]) + ggtitle("umap")
p18 <- plotUMAP(sce_sub, colour_by=topgenes[18]) + ggtitle("umap")
p19 <- plotUMAP(sce_sub, colour_by=topgenes[19]) + ggtitle("umap")
p20 <- plotUMAP(sce_sub, colour_by=topgenes[20]) + ggtitle("umap")

fig <- cowplot::plot_grid(p1, p2,  p3, p4, p5, p6, p7, p8, p9, p10, 
                          p11, p12, p13, p14, p15, p16, p17, p18, p19, p20,
                          ncol = 5)

pdf(file.path(workingPath, "figures/2019-04-02-slingshot-hvg.pdf"), width=25,height=20)
print(fig)
dev.off()
```


# monocle

Work in progress... 

```{r, eval=FALSE}
library(monocle)
      
# Converting the exprs data in log scale back to original scale
data <- 2^logcounts(sce_sub) - metadata(sce_sub)$log.exprs.offset
fd <- rowData(sce_sub)
colnames(fd)[2] <- "gene_short_name"
pd <- colData(sce_sub)
monocle_cds <- newCellDataSet(data, 
            phenoData = AnnotatedDataFrame(data=as.data.frame(pd)), 
            featureData = AnnotatedDataFrame(data=as.data.frame(fd)), 
            lowerDetectionLimit = 1, expressionFamily = negbinomial.size())
monocle_cds@auxOrderingData$scran <- sce_sub

disp_table <- dispersionTable(monocle_cds)
ordering_genes <- subset(disp_table, mean_expression >= 0.1)
cds <- setOrderingFilter(cds, ordering_genes)
cds <- reduceDimension(cds)
cds <- orderCells(cds)

```





## Fraction of cancer cells

```{r}
# f = prob(cancer allele); 1-f = prob(not being a cancer allele)
# f(cancer) = f / (f + 2*(1-f) + f) = f / 2
# therfore need to multiply by 2 to recover true cancer
frac_cancer <- function(n_mut, n_wt, p_time){
  2 * (n_mut / (n_mut + n_wt))
}
```


```{r}
# p(true cancer cell | obs wt cell) = 
#     P(obs wt | true cancer) * p(true cancer)   \ 
#     (P(obs wt | true cancer) * p(true cancer)  + P(obs wt | not cancer) * p(not cancer) ) = 
#     1/2 * f(t)  \ ( 1/2 * f(t)  + 1 * 1-f(t) )
```


